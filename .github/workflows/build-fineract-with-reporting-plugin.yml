name: Build Fineract With Reporting Plugin

on:
  workflow_dispatch:
    inputs:
      fineract_ref:
        description: "Branch, tag, or SHA for Taalam-Innovations-KE/fineract"
        required: true
        default: "develop"
      plugin_source:
        description: "How to source reporting plugin artifacts"
        required: true
        default: "prebuilt"
        type: choice
        options:
          - prebuilt
          - build-from-source
      plugin_ref:
        description: "Branch, tag, or SHA for Taalam-Innovations-KE/taalam-fincore-reporting-plugin (used only when plugin_source=build-from-source)"
        required: false
        default: "develop"
      plugin_zip_url:
        description: "Prebuilt reporting plugin ZIP URL (used when plugin_source=prebuilt)"
        required: true
        default: "https://sourceforge.net/projects/mifos/files/mifos-plugins/MifosReportingPlugin/MifosReportingPlugin-1.14.0.zip/download"
      plugin_zip_sha256:
        description: "Optional SHA256 for plugin_zip_url (recommended)"
        required: false
        default: ""
      reports_datasource_host:
        description: "Host value to inject into PRPT datasource URLs/properties"
        required: true
        default: ""
      reports_datasource_user:
        description: "Username to inject into PRPT datasource properties"
        required: true
        default: ""
      reports_datasource_password:
        description: "Password to inject into PRPT datasource properties"
        required: true
        default: ""
      image_repository:
        description: "Target image repository (for example taalamke/taalam-fineract)"
        required: true
        default: "taalamke/taalam-fineract"
      push_image:
        description: "Push built images to registry"
        required: true
        default: true
        type: boolean

permissions:
  contents: read
  packages: write

jobs:
  build:
    runs-on: ubuntu-24.04

    steps:
      - name: Resolve build parameters
        id: params
        env:
          INPUT_FINERACT_REF: ${{ inputs.fineract_ref }}
          INPUT_PLUGIN_SOURCE: ${{ inputs.plugin_source }}
          INPUT_PLUGIN_REF: ${{ inputs.plugin_ref }}
          INPUT_PLUGIN_ZIP_URL: ${{ inputs.plugin_zip_url }}
          INPUT_PLUGIN_ZIP_SHA256: ${{ inputs.plugin_zip_sha256 }}
          INPUT_REPORTS_DATASOURCE_HOST: ${{ inputs.reports_datasource_host }}
          INPUT_REPORTS_DATASOURCE_USER: ${{ inputs.reports_datasource_user }}
          INPUT_REPORTS_DATASOURCE_PASSWORD: ${{ inputs.reports_datasource_password }}
          INPUT_IMAGE_REPOSITORY: ${{ inputs.image_repository }}
          INPUT_PUSH_IMAGE: ${{ inputs.push_image }}
        run: |
          set -euo pipefail

          fineract_ref="${INPUT_FINERACT_REF:-develop}"
          plugin_source="${INPUT_PLUGIN_SOURCE:-prebuilt}"
          plugin_ref="${INPUT_PLUGIN_REF:-develop}"
          plugin_zip_url="${INPUT_PLUGIN_ZIP_URL:-}"
          plugin_zip_sha256="${INPUT_PLUGIN_ZIP_SHA256:-}"
          reports_datasource_host="${INPUT_REPORTS_DATASOURCE_HOST:-}"
          reports_datasource_user="${INPUT_REPORTS_DATASOURCE_USER:-}"
          reports_datasource_password="${INPUT_REPORTS_DATASOURCE_PASSWORD:-}"
          image_repository="${INPUT_IMAGE_REPOSITORY:-taalamke/taalam-fineract}"
          push_image="${INPUT_PUSH_IMAGE:-true}"

          image_repository="$(echo "${image_repository}" | tr '[:upper:]' '[:lower:]')"
          push_image="$(echo "${push_image}" | tr '[:upper:]' '[:lower:]')"
          plugin_source="$(echo "${plugin_source}" | tr '[:upper:]' '[:lower:]')"
          plugin_zip_sha256="$(echo "${plugin_zip_sha256}" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"
          reports_datasource_host="$(echo "${reports_datasource_host}" | tr -d '[:space:]')"
          reports_datasource_user="$(echo "${reports_datasource_user}" | tr -d '[:space:]')"

          if [ "${push_image}" != "true" ] && [ "${push_image}" != "false" ]; then
            echo "Invalid push_image value: ${push_image}" >&2
            exit 1
          fi

          if [ "${plugin_source}" != "prebuilt" ] && [ "${plugin_source}" != "build-from-source" ]; then
            echo "Invalid plugin_source value: ${plugin_source}" >&2
            exit 1
          fi

          if [ "${plugin_source}" = "prebuilt" ] && [ -z "${plugin_zip_url}" ]; then
            echo "plugin_zip_url is required when plugin_source=prebuilt" >&2
            exit 1
          fi

          if [ -z "${reports_datasource_host}" ]; then
            echo "reports_datasource_host cannot be empty" >&2
            exit 1
          fi

          if [ -z "${reports_datasource_user}" ]; then
            echo "reports_datasource_user cannot be empty" >&2
            exit 1
          fi

          if [ -z "${reports_datasource_password}" ]; then
            echo "reports_datasource_password cannot be empty" >&2
            exit 1
          fi

          echo "::add-mask::${reports_datasource_password}"

          first_segment="${image_repository%%/*}"
          if [ "${first_segment}" = "${image_repository}" ]; then
            registry="docker.io"
          elif [[ "${first_segment}" == *.* || "${first_segment}" == *:* || "${first_segment}" == "localhost" ]]; then
            registry="${first_segment}"
          else
            registry="docker.io"
          fi

          if [ "${registry}" != "docker.io" ] && [ "${registry}" != "ghcr.io" ]; then
            echo "Unsupported registry: ${registry}. Use docker.io or ghcr.io." >&2
            exit 1
          fi

          echo "fineract_ref=${fineract_ref}" >> "${GITHUB_OUTPUT}"
          echo "plugin_source=${plugin_source}" >> "${GITHUB_OUTPUT}"
          echo "plugin_ref=${plugin_ref}" >> "${GITHUB_OUTPUT}"
          echo "plugin_zip_url=${plugin_zip_url}" >> "${GITHUB_OUTPUT}"
          echo "plugin_zip_sha256=${plugin_zip_sha256}" >> "${GITHUB_OUTPUT}"
          echo "reports_datasource_host=${reports_datasource_host}" >> "${GITHUB_OUTPUT}"
          echo "reports_datasource_user=${reports_datasource_user}" >> "${GITHUB_OUTPUT}"
          echo "image_repository=${image_repository}" >> "${GITHUB_OUTPUT}"
          echo "push_image=${push_image}" >> "${GITHUB_OUTPUT}"
          echo "registry=${registry}" >> "${GITHUB_OUTPUT}"

      - name: Checkout orchestrator repository
        uses: actions/checkout@v4

      - name: Checkout Fineract source
        uses: actions/checkout@v4
        with:
          repository: Taalam-Innovations-KE/fineract
          ref: ${{ steps.params.outputs.fineract_ref }}
          path: fineract-src
          fetch-depth: 0
          fetch-tags: true
          token: ${{ secrets.CROSS_REPO_TOKEN != '' && secrets.CROSS_REPO_TOKEN || github.token }}

      - name: Checkout reporting plugin source
        if: steps.params.outputs.plugin_source == 'build-from-source'
        uses: actions/checkout@v4
        with:
          repository: Taalam-Innovations-KE/taalam-fincore-reporting-plugin
          ref: ${{ steps.params.outputs.plugin_ref }}
          path: plugin-src
          token: ${{ secrets.CROSS_REPO_TOKEN != '' && secrets.CROSS_REPO_TOKEN || github.token }}

      - name: Compute image tags
        id: tags
        run: |
          set -euo pipefail

          fineract_sha="$(git -C fineract-src rev-parse --short=12 HEAD)"
          if [ "${{ steps.params.outputs.plugin_source }}" = "build-from-source" ]; then
            plugin_sha="$(git -C plugin-src rev-parse --short=12 HEAD)"
          else
            plugin_sha="$(printf '%s' "${{ steps.params.outputs.plugin_zip_url }}" | sha256sum | cut -c1-12)"
          fi

          tag="${fineract_sha}-${plugin_sha}"
          local_image="fineract-with-reporting:${tag}"
          remote_image="${{ steps.params.outputs.image_repository }}:${tag}"
          remote_image_latest="${{ steps.params.outputs.image_repository }}:latest"
          base_image="fineract-base:${fineract_sha}"

          echo "fineract_sha=${fineract_sha}" >> "${GITHUB_OUTPUT}"
          echo "plugin_sha=${plugin_sha}" >> "${GITHUB_OUTPUT}"
          echo "tag=${tag}" >> "${GITHUB_OUTPUT}"
          echo "base_image=${base_image}" >> "${GITHUB_OUTPUT}"
          echo "local_image=${local_image}" >> "${GITHUB_OUTPUT}"
          echo "remote_image=${remote_image}" >> "${GITHUB_OUTPUT}"
          echo "remote_image_latest=${remote_image_latest}" >> "${GITHUB_OUTPUT}"

      - name: Login to Docker Hub
        if: steps.params.outputs.push_image == 'true' && steps.params.outputs.registry == 'docker.io'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        if: steps.params.outputs.push_image == 'true' && steps.params.outputs.registry == 'ghcr.io'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Set up JDK 21 (build-from-source)
        if: steps.params.outputs.plugin_source == 'build-from-source'
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"
          cache: maven

      - name: Set up JDK 21 (prebuilt)
        if: steps.params.outputs.plugin_source == 'prebuilt'
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      - name: Set up Gradle cache
        uses: gradle/actions/setup-gradle@v4

      - name: Build Fineract base image from source
        working-directory: fineract-src
        run: |
          set -euo pipefail
          ./gradlew --no-daemon --console=plain :fineract-provider:jibDockerBuild \
            -Djib.to.image=${{ steps.tags.outputs.base_image }} \
            -x test -x cucumber

      - name: Build reporting plugin and dependencies
        if: steps.params.outputs.plugin_source == 'build-from-source'
        working-directory: plugin-src
        run: |
          set -euo pipefail
          mvn -B -ntp clean package dependency:copy-dependencies \
            -DskipTests \
            -DincludeScope=runtime \
            -DexcludeGroupIds=org.apache.fineract \
            -DoutputDirectory=target/dependency

      - name: Assemble Docker context with plugin and reports
        id: context
        run: |
          set -euo pipefail
          context_dir="${RUNNER_TEMP}/fineract-reporting-context-${{ steps.tags.outputs.tag }}"
          plugin_stage_dir="${RUNNER_TEMP}/plugin-stage-${{ steps.tags.outputs.tag }}"
          mkdir -p "${context_dir}/plugin-libs" "${context_dir}/pentahoReports/Postgresql" "${context_dir}/pentahoReports/MariaDB" "${plugin_stage_dir}/candidates"
          base_artifacts_file="${context_dir}/base-artifacts.txt"

          docker run --rm --entrypoint sh ${{ steps.tags.outputs.base_image }} -c '
            if [ -d /app/libs ]; then
              ls -1 /app/libs/*.jar 2>/dev/null || true
            fi
          ' | xargs -r -n1 basename \
            | sed -E 's/\.jar$//; s/-[0-9].*$//' \
            | sort -u > "${base_artifacts_file}"

          if [ ! -s "${base_artifacts_file}" ]; then
            echo "Failed to detect base image runtime libraries under /app/libs." >&2
            exit 1
          fi

          if [ "${{ steps.params.outputs.plugin_source }}" = "build-from-source" ]; then
            plugin_jar="$(find plugin-src/target -maxdepth 1 -type f -name 'pentaho-plugin-*.jar' ! -name '*sources*' ! -name '*javadoc*' | head -n 1)"
            if [ -z "${plugin_jar}" ]; then
              echo "Plugin jar not found under plugin-src/target" >&2
              exit 1
            fi

            cp "${plugin_jar}" "${plugin_stage_dir}/candidates/"
            if compgen -G "plugin-src/target/dependency/*.jar" > /dev/null; then
              cp plugin-src/target/dependency/*.jar "${plugin_stage_dir}/candidates/"
            fi

            cp -R "plugin-src/pentahoReports/Postgresql/." "${context_dir}/pentahoReports/Postgresql/"
            cp -R "plugin-src/pentahoReports/MariaDB/." "${context_dir}/pentahoReports/MariaDB/"
          else
            plugin_zip_file="${plugin_stage_dir}/plugin.zip"
            plugin_extract_dir="${plugin_stage_dir}/extracted"

            curl -fL --retry 5 --retry-all-errors --connect-timeout 20 \
              -o "${plugin_zip_file}" \
              "${{ steps.params.outputs.plugin_zip_url }}"

            if [ -n "${{ steps.params.outputs.plugin_zip_sha256 }}" ]; then
              echo "${{ steps.params.outputs.plugin_zip_sha256 }}  ${plugin_zip_file}" | sha256sum -c -
            fi

            unzip -q "${plugin_zip_file}" -d "${plugin_extract_dir}"

            libs_dir="$(find "${plugin_extract_dir}" -type d -name libs | head -n 1)"
            if [ -n "${libs_dir}" ] && compgen -G "${libs_dir}/*.jar" > /dev/null; then
              cp "${libs_dir}"/*.jar "${plugin_stage_dir}/candidates/"
            else
              # Newer prebuilt ZIPs place jars in the root plugin directory (no libs/).
              while IFS= read -r jar_file; do
                cp "${jar_file}" "${plugin_stage_dir}/candidates/"
              done < <(find "${plugin_extract_dir}" -type f -name '*.jar' ! -name '*sources*' ! -name '*javadoc*' | sort)
            fi

            if ! compgen -G "${plugin_stage_dir}/candidates/*.jar" > /dev/null; then
              echo "Could not locate plugin jars in prebuilt plugin ZIP." >&2
              find "${plugin_extract_dir}" -maxdepth 4 -type d | sort >&2
              exit 1
            fi

            postgres_reports_dir="$(find "${plugin_extract_dir}" -type d \( -path '*pentahoReports/Postgresql' -o -path '*/Postgresql' \) | head -n 1)"
            mariadb_reports_dir="$(find "${plugin_extract_dir}" -type d \( -path '*pentahoReports/MariaDB' -o -path '*/MariaDB' \) | head -n 1)"
            if [ -z "${postgres_reports_dir}" ] || [ -z "${mariadb_reports_dir}" ]; then
              echo "Could not locate Postgresql/MariaDB report directories in prebuilt plugin ZIP." >&2
              find "${plugin_extract_dir}" -maxdepth 5 -type d | sort >&2
              exit 1
            fi

            cp -R "${postgres_reports_dir}/." "${context_dir}/pentahoReports/Postgresql/"
            cp -R "${mariadb_reports_dir}/." "${context_dir}/pentahoReports/MariaDB/"
          fi

          xml_escape() {
            printf '%s' "$1" \
              | sed -e 's/&/\&amp;/g' \
                    -e 's/</\&lt;/g' \
                    -e 's/>/\&gt;/g' \
                    -e 's/"/\&quot;/g' \
                    -e "s/'/\&apos;/g"
          }

          # Rewrite PRPT datasource defaults so report SQL metadata/cache prep resolves in this runtime.
          rewrite_prpt_datasource() {
            report_dir="$1"
            target_host="$2"
            target_user="$3"
            target_password="$4"
            target_user_xml="$(xml_escape "${target_user}")"
            target_password_xml="$(xml_escape "${target_password}")"
            while IFS= read -r prpt_file; do
              tmp_dir="$(mktemp -d)"
              unzip -q "${prpt_file}" -d "${tmp_dir}"
              ds_file="${tmp_dir}/datasources/sql-ds.xml"
              if [ -f "${ds_file}" ]; then
                TARGET_HOST="${target_host}" \
                TARGET_USER="${target_user_xml}" \
                TARGET_PASSWORD="${target_password_xml}" \
                perl -0777 -i -pe '
                  s#(<data:url>\s*jdbc:[^:]+://)[^/:<]+(:\d+/[^<]*</data:url>)#$1.$ENV{TARGET_HOST}.$2#ge;
                  s#(<data:property name="::pentaho-reporting::hostname">)[^<]*(</data:property>)#$1.$ENV{TARGET_HOST}.$2#ge;
                  s#(<data:property name="user">)[^<]*(</data:property>)#$1.$ENV{TARGET_USER}.$2#ge;
                  s#(<data:property name="password">)[^<]*(</data:property>)#$1.$ENV{TARGET_PASSWORD}.$2#ge;
                ' "${ds_file}"

                if ! grep -q 'tenantUrl' "${ds_file}" \
                  || ! grep -q 'username' "${ds_file}" \
                  || ! grep -q 'password' "${ds_file}"; then
                  echo "PRPT datasource does not include runtime tenantUrl/username/password tokens: ${prpt_file}" >&2
                  exit 1
                fi
              fi
              (cd "${tmp_dir}" && zip -qr "${prpt_file}.new" .)
              mv "${prpt_file}.new" "${prpt_file}"
              rm -rf "${tmp_dir}"
            done < <(find "${report_dir}" -type f -name '*.prpt' | sort)
          }

          rewrite_prpt_datasource \
            "${context_dir}/pentahoReports/Postgresql" \
            "${{ steps.params.outputs.reports_datasource_host }}" \
            "${{ steps.params.outputs.reports_datasource_user }}" \
            "${{ inputs.reports_datasource_password }}"
          rewrite_prpt_datasource \
            "${context_dir}/pentahoReports/MariaDB" \
            "${{ steps.params.outputs.reports_datasource_host }}" \
            "${{ steps.params.outputs.reports_datasource_user }}" \
            "${{ inputs.reports_datasource_password }}"

          while IFS= read -r dep; do
            dep_name="$(basename "${dep}")"
            dep_artifact="$(echo "${dep_name}" | sed -E 's/\.jar$//; s/-[0-9].*$//')"

            if grep -Fxq "${dep_artifact}" "${base_artifacts_file}"; then
              continue
            fi

            if [[ "${dep_name}" == fineract-*.jar || "${dep_name}" == commons-lang3-*.jar || "${dep_name}" == *spring*.jar ]]; then
              continue
            fi

            cp "${dep}" "${context_dir}/plugin-libs/"
          done < <(find "${plugin_stage_dir}/candidates" -maxdepth 1 -type f -name '*.jar' | sort)

          if ! compgen -G "${context_dir}/plugin-libs/*.jar" > /dev/null; then
            echo "No plugin jars were selected for /app/plugins." >&2
            exit 1
          fi

          if compgen -G "${context_dir}/plugin-libs/fineract-*.jar" > /dev/null \
            || compgen -G "${context_dir}/plugin-libs/commons-lang3-*.jar" > /dev/null \
            || compgen -G "${context_dir}/plugin-libs/*spring*.jar" > /dev/null; then
            echo "Found disallowed framework jars in plugin-libs context." >&2
            ls -1 "${context_dir}/plugin-libs" >&2
            exit 1
          fi

          font_mapper_found="false"
          for jar_file in "${context_dir}"/plugin-libs/*.jar; do
            if jar tf "${jar_file}" | grep -q 'com/lowagie/text/pdf/FontMapper.class'; then
              echo "Found FontMapper in $(basename "${jar_file}")"
              font_mapper_found="true"
              break
            fi
          done

          if [ "${font_mapper_found}" != "true" ]; then
            echo "Missing com/lowagie/text/pdf/FontMapper.class in plugin jars; PDF export will fail." >&2
            ls -1 "${context_dir}/plugin-libs" >&2
            exit 1
          fi

          cp docker/fineract-with-reporting-plugin.Dockerfile "${context_dir}/Dockerfile"

          echo "context_dir=${context_dir}" >> "${GITHUB_OUTPUT}"

      - name: Build final Fineract image with reporting plugin embedded
        run: |
          set -euo pipefail
          docker build \
            --build-arg BASE_IMAGE=${{ steps.tags.outputs.base_image }} \
            -t ${{ steps.tags.outputs.local_image }} \
            -f ${{ steps.context.outputs.context_dir }}/Dockerfile \
            ${{ steps.context.outputs.context_dir }}

      - name: Validate embedded plugin and report path
        run: |
          set -euo pipefail
          docker run --rm \
            -e REPORTS_DS_HOST="${{ steps.params.outputs.reports_datasource_host }}" \
            -e REPORTS_DS_USER="${{ steps.params.outputs.reports_datasource_user }}" \
            -e REPORTS_DS_PASSWORD="${{ inputs.reports_datasource_password }}" \
            --entrypoint sh ${{ steps.tags.outputs.local_image }} -c '
            set -e
            ls -1 /app/plugins/*.jar >/dev/null
            if ls -1 /app/plugins/fineract-*.jar >/dev/null 2>&1 \
              || ls -1 /app/plugins/commons-lang3-*.jar >/dev/null 2>&1 \
              || ls -1 /app/plugins/*spring*.jar >/dev/null 2>&1; then
              echo "Disallowed framework jars detected under /app/plugins; this will cause classpath conflicts."
              exit 1
            fi
            test -d /app/pentahoReports/Postgresql
            test -n "$(ls -A /app/pentahoReports/Postgresql)"
            test -d /app/pentahoReports/MariaDB
            test -n "$(ls -A /app/pentahoReports/MariaDB)"
            pg_report="$(find /app/pentahoReports/Postgresql -type f -name "*.prpt" | head -n 1)"
            unzip -p "${pg_report}" datasources/sql-ds.xml > /tmp/pg-ds.xml
            grep -F "<data:property name=\"::pentaho-reporting::hostname\">${REPORTS_DS_HOST}</data:property>" /tmp/pg-ds.xml >/dev/null
            grep -F "<data:property name=\"user\">${REPORTS_DS_USER}</data:property>" /tmp/pg-ds.xml >/dev/null
            mariadb_report="$(find /app/pentahoReports/MariaDB -type f -name "*.prpt" | head -n 1)"
            unzip -p "${mariadb_report}" datasources/sql-ds.xml > /tmp/mariadb-ds.xml
            grep -F "<data:property name=\"::pentaho-reporting::hostname\">${REPORTS_DS_HOST}</data:property>" /tmp/mariadb-ds.xml >/dev/null
            grep -F "<data:property name=\"user\">${REPORTS_DS_USER}</data:property>" /tmp/mariadb-ds.xml >/dev/null
            test "$FINERACT_PENTAHO_REPORTS_PATH" = "/app/pentahoReports/Postgresql"
            command -v fc-list >/dev/null 2>&1
            fc-list : family >/dev/null
          '

      - name: Push image
        if: steps.params.outputs.push_image == 'true'
        run: |
          set -euo pipefail
          docker tag ${{ steps.tags.outputs.local_image }} ${{ steps.tags.outputs.remote_image }}
          docker tag ${{ steps.tags.outputs.local_image }} ${{ steps.tags.outputs.remote_image_latest }}
          docker push ${{ steps.tags.outputs.remote_image }}
          docker push ${{ steps.tags.outputs.remote_image_latest }}

      - name: Build summary
        run: |
          {
            echo "### Fineract Reporting Image Build"
            echo ""
            echo "- Trigger: \`${GITHUB_EVENT_NAME}\`"
            echo "- Fineract ref: \`${{ steps.params.outputs.fineract_ref }}\`"
            echo "- Fineract SHA: \`${{ steps.tags.outputs.fineract_sha }}\`"
            echo "- Plugin source: \`${{ steps.params.outputs.plugin_source }}\`"
            echo "- Plugin ref: \`${{ steps.params.outputs.plugin_ref }}\`"
            if [ "${{ steps.params.outputs.plugin_source }}" = "prebuilt" ]; then
              echo "- Plugin ZIP: \`${{ steps.params.outputs.plugin_zip_url }}\`"
            fi
            echo "- Reports datasource host override: \`${{ steps.params.outputs.reports_datasource_host }}\`"
            echo "- Reports datasource user override: \`${{ steps.params.outputs.reports_datasource_user }}\`"
            echo "- Reports datasource password override: \`***\`"
            echo "- Plugin SHA: \`${{ steps.tags.outputs.plugin_sha }}\`"
            echo "- Image tag: \`${{ steps.tags.outputs.tag }}\`"
            echo "- Embedded report templates: \`Postgresql\` and \`MariaDB\`"
            echo "- Default report path: \`/app/pentahoReports/Postgresql\`"
            echo "- MariaDB override: \`FINERACT_PENTAHO_REPORTS_PATH=/app/pentahoReports/MariaDB\`"
            echo "- Registry: \`${{ steps.params.outputs.registry }}\`"
            if [ "${{ steps.params.outputs.push_image }}" = "true" ]; then
              echo "- Published image: \`${{ steps.tags.outputs.remote_image }}\`"
              echo "- Published image alias: \`${{ steps.tags.outputs.remote_image_latest }}\`"
            else
              echo "- Published image: skipped (push_image=false)"
            fi
          } >> "${GITHUB_STEP_SUMMARY}"
